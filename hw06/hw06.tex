\documentclass[fleqn]{homework}

\student{Stephen Brennan (smb196)}
\course{EECS 477}
\assignment{Homework 6}
\duedate{December 4, 2015}

\usepackage{algpseudocode}
\usepackage{enumerate}
\usepackage{mathtools}
%\usepackage{graphicx}

\begin{document}
  \maketitle

  \begin{problem}{1}
    \begin{question}
      A manufacturer of pharmaceutical substances has a product line consisting
      of $n$ substances. The substances have completely different properties,
      yet two substances can be distinguished only through sophisticated
      chemical tests. There are $k$ possible chemical tests and, in each test, a
      substance either tests positive or tests negative. The manufacturer wishes
      to assign a product code to each substance. The product code is a binary
      string representing the test outcome for that particular substance. For
      example, if $k=4$, and a substance passes test 1, 3, and 4 but fails test
      2, its code would be 1011.  However, some of the tests are redundant: for
      example, there is no point to encode a test that is passed by all of the
      $n$ available pharmaceutical substances, nor a test whose outcome could be
      inferred by that of another test(s). The manufacturer would like to
      determine if $t<k$ tests are sufficient for the encoding. In other words,
      he needs $t$ out of the $k$ available tests with the property that any two
      of the $n$ substances differ on at least one of the $t$ test outcomes.
      \begin{enumerate}[a.]
      \item Argue that the manufacturer needs at least $t=\Omega(\log n)$ tests
        to differentiate the $n$ substances from each other.
      \item Model the manufacturer's problem as an integer linear program.
      \item Use the program to devise a pimal-dual approximation algorithm for
        the manufacturer's problem.
      \item Use the program to devise a randomized approximation algorithm for
        the manufacturer's problem.
      \end{enumerate}
    \end{question}
    \begin{enumerate}[a.]
    \item For $t$ tests, there are $2^t$ product codes, so there can be at most
      $2^t$ products distinguished by these tests (and this is only if the tests
      provide the best case amount of information).  It follows that for $n$
      products, the minimum number of tests is $\lceil \log n \rceil$, so
      $t \in \Omega(\log n)$.
    \item We define the variable $x_i$ for $1 \le i \le k$ as follows:
      \begin{equation*}
        x_i = \left\{\begin{array}{ll}
            1 &\text{ if test }i\text{ is included in the set} \\
            0 &\text{ otherwise}
          \end{array}\right.
      \end{equation*}
      These $x_i$ are the variables we need to find.  Similarly, we define the
      variables $d_{iab}$ for $a,b \in [1, n]$:
      \begin{equation*}
        d_{iab} = \left\{\begin{array}{ll}
                           1 &\text{ if test }i\text{ distinguishes substances }a,b \\
                           0 &\text{ otherwise}
                         \end{array}\right.
      \end{equation*}
      These $d_{iab}$ variables are inputs to the problem.  With this
      formulation, we can define the following integer linear program to solve
      this problem:

      \begin{align*}
        \min \sum_{i=1}^k x_i &\text{ s.t.} \\
        \sum_{i=1}^k d_{iab} x_i \ge 0 &\:\:\:\: \forall a,b \in [1,n]: a \ne b \\
        x_i \in \{0,1\} &\:\:\:\: \forall i \in [1, k] \\
      \end{align*}
    \item Here is the beginnings of the formulation of the dual of this program:
      \begin{align*}
        \max 0 &\text{ s.t.} \\
        \sum_{a,b \in [1,n]: a \ne b} d_{iab} \alpha_{ab} \le 1 &\:\:\:\: \forall i \in [1,k] \\
      \end{align*}

      While this dual is not complete, it can give us the following
      complementary slackness conditions:

      \begin{enumerate}
      \item $x_i \left(\sum_{a,b \in [1,n]: a \ne b} d_{iab} \alpha_{ab} - 1\right) = 0$
      \item $\alpha_{ab} \left(\sum_{i=0}^k x_i d_{iab}\right) = 0$
      \end{enumerate}

      We can use this to come up with a primal-dual algorithm very similar to
      the one presented in class for Hitting Set:

      \begin{algorithmic}
        \Function{Primal-Dual}{$d_{ab}$ values}
          \State $\vec{x} \gets 0$
          \State $\vec{\alpha} \gets 0$
          \While{$\exists a,b: \sum_{i=1}^k x_i d_{iab} = 0$}
            \Comment{while $\vec{x}$ is still infeasible}
            \State increase $\alpha_{ab}$ until $\exists x_i: \sum_{a,b} \alpha_{ab} d_{iab} - 1 = 0$.
            \State $x_i \gets 1$
          \EndWhile
          \State \Return $\vec{x}$
        \EndFunction
      \end{algorithmic}
      This algorithm starts with an $\vec{x}$ and $\vec{\alpha}$ linked by
      complementary slackness, but $\vec{x} = 0$ is not feasible (it represents
      an empty set of tests).  At each iteration, it selects a pair of
      substances which cannot be distinguished with the current set of tests.
      It increases the $\alpha$ value until a test is identified that will
      distinguish them.  This continues until all pairs of substances can be
      distinguished, at which point the set of $t$ tests are the tests $i$ such
      that $x_i=1$.
    \item The linear relaxation of the primal ILP is:
      \begin{align*}
        \min \sum_{i=1}^k x_i &\text{ s.t.} \\
        \sum_{i=1}^k d_{iab} x_i \ge 0 &\:\:\:\: \forall a,b \in [1,n]: a \ne b \\
        0 \le x_i \le 1 &\:\:\:\: \forall i \in [1, k] \\
      \end{align*}
      Thus, the randomized approximation algorithm associated with the
      manufacture's problem would be to solve this linear program, treat the
      $x_i$'s as probabilities, and include each test $i$ in the set of tests
      with probability $x_i$.  This would be repeated multiple times so as to
      increase the probability that the solution is feasible.
    \end{enumerate}

  \end{problem}

  \begin{problem}{2}
    \begin{question}
      The \textit{Bloom filter} is a data structure that is used to represent
      sets in applications that require extreme speed at the potential of a
      small error probability (e.g., packet logging at line speed in
      networks). The Bloom filter uses $k$ hash functions $h_1, h_2, ..., h_k$
      and a binary array $A$ of size $m$. You can assume that $h_i(x)$ is
      equally likely to be any index in the array $A$. Initially, the array $A$
      is 0. An element $x$ is added to set by setting
      $A[h_1(x)], A[h_2(x)], \dots, A[h_k(x)]$ to 1. To check whether $x$
      belongs to the set, the data structure tests whether
      $A[h_1(x)], A[h_2(x)], \dots, A[h_k(x)]$ are all equal to 1: if so, $x$ is
      reported as being in the set, otherwise $x$ is reported as not being in
      the set. Due to potential collisions in the hashing functions, it is
      possible that $x$ is reported as belonging to the set even if it does
      not. However, the data structure is always correct when it reports that
      $x$ does not belong to the set. The data structure does not support
      removal of elements from the set. Assuming that the $n<km/2$ elements have
      been inserted in the Bloom filter, derive a bound on the probability that
      the Bloom filter returns a false positive response.
    \end{question}

    Since the hash function values are equally likely, the probability that the
    hash of any element is equal to any array index is $\frac{1}{m}$.  We can
    use this to compute the probability that $A[j] = 1$:

    \begin{align*}
      Pr[A[j] = 1] &= 1 - Pr[A[j] = 0] \\
                   &= 1 - Pr\left[\bigcap_{i=1}^n \bigcap_{\ell=1}^k \{h_\ell(x_i) \ne j\}\right] \\
                   &= 1 - \prod_{i=1}^n \prod_{\ell=1}^k \left(1 - \frac{1}{m}\right) \\
                   &= 1 - \left(1 - \frac{1}{m}\right)^{nk}
    \end{align*}

    From this, we can determine the probability that $k$ indices are all 1:

    \begin{align*}
      Pr[A[h_\ell(x)] = 1, 1 \le \ell \le k] &= \left(1 - \left(1 - \frac{1}{m}\right)^{nk}\right)^k
    \end{align*}

    However, in the worst-case for the filter, all $k$ hash functions evaluate
    to the same index, and so the worst case probability of a false positive is
    simply:

    \begin{align*}
      Pr[\text{false positive}] \le 1 - \left(1 - \frac{1}{m}\right)^{nk}
    \end{align*}

    We might try to simplify this upper bound by noting that since
    $n < \frac{mk}{2}$, we also have $nk < \frac{mk^2}{2}$.  This would mean
    that:

    \begin{align*}
      \left(1 - \frac{1}{m}\right)^{nk} \ge 
      \left(1 - \frac{1}{m}\right)^{\frac{mk^2}{2}} = 
      \left(\left(1 - \frac{1}{m}\right)^m\right)^{\frac{k^2}{2}}
    \end{align*}

    However, from there, we can only say that
    $\left(1 - \frac{1}{m}\right)^m \le e^{-1}$, and this will not let us say
    anything meaningful about the original bound.  So, we are stuck with the
    bound on the false positive rate given above.
  \end{problem}

  \begin{problem}{3}
    \begin{question}
      The \textit{quadratic relaxation} of MAX CUT is:
      \begin{equation*}
        \max \left\{\sum a_{ij} \frac{1 - v_i \cdot v_j}{2}: -e \le v_i \le e\right\},
      \end{equation*}
      where the $v_i$'s are $n$-dimensional vectors, the underlying graph has
      $n$ vertices, and $e$ is the vector of all ones.
      \begin{enumerate}[a.]
      \item Show that, in the optimal solution of this optimization problem,
        every non-zero vector has (at least) a component of value $+1$ or $-1$.
      \item Show that there exists an optimal solution where no vector is zero.
      \item Briefly summarize the main similarities and differences of the
        quadratic and the semi-definite programming relaxations of MAX CUT.
      \item In the next question, you will be using the following general fact
        on vectors and matrixes. Let $v_1$ and $v_2$ be two $n$-dimensional
        vectors and define the $2n$-dimensional vector
        \begin{equation*}
          v = \begin{bmatrix*} v_1 \\ v_2 \end{bmatrix*}
        \end{equation*}
        Define a matrix $H$ such that $v_1 v_2 = v^T H v$.
      \item Write the MAX CUT quadratic relaxation as a \textit{quadratic
          program} of the form $\min\{x^TQx: -e \le x \le e \}$, where $e$ is
        the vector of all ones.
      \end{enumerate}
    \end{question}
  \end{problem}

  \begin{problem}{4}
    \begin{question}
      Implement and solve the MAX CUT quadratic program in octave for a complete
      graph with three vertices, with weights $a_{ij} > 0$ of your choice.
    \end{question}
  \end{problem}

  \begin{problem}{5}
    \begin{question}
      A sequence of n operations is performed on a data structure.  The $i$th
      operation takes time $i$ if $i$ is a power of 2, and 1
      otherwise. Determine the amortized cost per operation using
      \begin{enumerate}[a.]
      \item Aggregate analysis
      \item The accounting method
      \item A potential function
      \end{enumerate}
    \end{question}
  \end{problem}

  \begin{problem}{6}
    \begin{question}
      Consider the \textit{Least Frequently Used (LFU)} caching rule, where the
      cached page that has been accessed the least often is the one that is
      evicted when the cache is full and a new page is requested. If there are
      ties, the page that has been in the page the longest is evicted. Show a
      sequence of $n$ requests that forces LFU to miss $\Omega(n)$ times for a
      cache of size $m$, whereas the optimal algorithm will only miss $O(m)$
      times.
    \end{question}
  \end{problem}

\end{document}